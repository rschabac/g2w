use super::ast;

//LALR makes compile times faster
#[LALR]
grammar;

match{
	r"\s*" => {},	//ignore whitespace
	r"//[^\n\r]*[\n\r]*" => {},	//remove line comments
	r"/\*([^*]|[\r\n]|(\*+([^*/]|[\r\n])))*\*+/" => {}, //remove block comments
	_
}

Comma<T>: Vec<T> = {
	<v:(<T> ",")*> <e:T?> => match e {
		None => v,
		Some(e) => {
			let mut v = v;
			v.push(e);
			v
		}
	}
}

//identifiers (variables, struct names, and type vars) cannot start with an underscore
Identifier: String = {
	<s:r#"[a-zA-Z][0-9a-zA-Z_]*"#> => s.to_owned()
}


pub Type: ast::Ty = {
	"bool" => ast::Ty::Bool,

	"u8" => ast::Ty::Int{signed: false, size: ast::IntSize::Size8},
	"u16" => ast::Ty::Int{signed: false, size: ast::IntSize::Size16},
	"u32" => ast::Ty::Int{signed: false, size: ast::IntSize::Size32},
	"u64" => ast::Ty::Int{signed: false, size: ast::IntSize::Size64},

	"i8" => ast::Ty::Int{signed: true, size: ast::IntSize::Size8},
	"i16" => ast::Ty::Int{signed: true, size: ast::IntSize::Size16},
	"i32" => ast::Ty::Int{signed: true, size: ast::IntSize::Size32},
	"i64" => ast::Ty::Int{signed: true, size: ast::IntSize::Size64},

	"f32" => ast::Ty::Float(ast::FloatSize::FSize32),
	"f64" => ast::Ty::Float(ast::FloatSize::FSize64),

	<t:Type> "*" => ast::Ty::Ptr(Some(Box::new(t))),
	"void" "*" => ast::Ty::Ptr(None),

	<t:Type> "[" <num:r"[0-9]+"> "]" => ast::Ty::Array{length: u64::from_str_radix(num, 10).unwrap(), typ: Box::new(t)},

	"struct" <id:Identifier> => ast::Ty::Struct(id),

	"'" <id:Identifier> => ast::Ty::TypeVar(id),

	"struct" <n:Identifier> "@" "<" <t:Type> ">" => ast::Ty::GenericStruct{type_param: Box::new(t), name: n}

}

//https://cs.wmich.edu/~gupta/teaching/cs4850/sumII06/The%20syntax%20of%20C%20in%20Backus-Naur%20form.htm

pub Expr: ast::Expr = {
	<e1: Expr> "||" <e2: LogAndExpr> => ast::Expr::Binop(Box::new(e1), ast::BinaryOp::Or, Box::new(e2)),
	<e2: LogAndExpr> => e2
}

LogAndExpr: ast::Expr = {
	<e1: LogAndExpr> "&&" <e2: BitOrExpr> => ast::Expr::Binop(Box::new(e1), ast::BinaryOp::And, Box::new(e2)),
	<e: BitOrExpr> => e
}

BitOrExpr: ast::Expr = {
	<e1: BitOrExpr> "|" <e2: BitXorExpr> => ast::Expr::Binop(Box::new(e1), ast::BinaryOp::Bitor, Box::new(e2)),
	<e: BitXorExpr> => e
}

BitXorExpr: ast::Expr = {
	<e1: BitXorExpr> "^" <e2: BitAndExpr> => ast::Expr::Binop(Box::new(e1), ast::BinaryOp::Bitxor, Box::new(e2)),
	<e: BitAndExpr> => e
}

BitAndExpr: ast::Expr = {
	<e1: BitAndExpr> "&" <e2: EqualityExpr> => ast::Expr::Binop(Box::new(e1), ast::BinaryOp::Bitand, Box::new(e2)),
	<e: EqualityExpr> => e
}

EqualityExpr: ast::Expr = {
	<e1: EqualityExpr> "==" <e2: RelationalExpr> => ast::Expr::Binop(Box::new(e1), ast::BinaryOp::Equ, Box::new(e2)),
	<e1: EqualityExpr> "!=" <e2: RelationalExpr> => ast::Expr::Binop(Box::new(e1), ast::BinaryOp::Neq, Box::new(e2)),
	<e: RelationalExpr> => e
}

RelationalExpr: ast::Expr = {
	<e1: RelationalExpr> "<" <e2: ShiftExpr> => ast::Expr::Binop(Box::new(e1), ast::BinaryOp::Lt, Box::new(e2)),
	<e1: RelationalExpr> "<=" <e2: ShiftExpr> => ast::Expr::Binop(Box::new(e1), ast::BinaryOp::Lte, Box::new(e2)),
	<e1: RelationalExpr> ">" <e2: ShiftExpr> => ast::Expr::Binop(Box::new(e1), ast::BinaryOp::Gt, Box::new(e2)),
	<e1: RelationalExpr> ">=" <e2: ShiftExpr> => ast::Expr::Binop(Box::new(e1), ast::BinaryOp::Gte, Box::new(e2)),
	<e: ShiftExpr> => e
}

ShiftExpr: ast::Expr = {
	<e1: ShiftExpr> "<<" <e2: AddExpr> => ast::Expr::Binop(Box::new(e1), ast::BinaryOp::Shl, Box::new(e2)),
	<e1: ShiftExpr> ">>" <e2: AddExpr> => ast::Expr::Binop(Box::new(e1), ast::BinaryOp::Shr, Box::new(e2)),
	<e1: ShiftExpr> ">>>" <e2: AddExpr> => ast::Expr::Binop(Box::new(e1), ast::BinaryOp::Sar, Box::new(e2)),
	<e: AddExpr> => e
}

AddExpr: ast::Expr = {
	<e1: AddExpr> "+" <e2: MulExpr> => ast::Expr::Binop(Box::new(e1), ast::BinaryOp::Add, Box::new(e2)),
	<e1: AddExpr> "-" <e2: MulExpr> => ast::Expr::Binop(Box::new(e1), ast::BinaryOp::Sub, Box::new(e2)),
	<e: MulExpr> => e
}

MulExpr: ast::Expr = {
	<e1: MulExpr> "*" <e2: UnaryExpr> => ast::Expr::Binop(Box::new(e1), ast::BinaryOp::Mul, Box::new(e2)),
	<e1: MulExpr> "/" <e2: UnaryExpr> => ast::Expr::Binop(Box::new(e1), ast::BinaryOp::Div, Box::new(e2)),
	<e1: MulExpr> "%" <e2: UnaryExpr> => ast::Expr::Binop(Box::new(e1), ast::BinaryOp::Mod, Box::new(e2)),
	<e: UnaryExpr> => e
}

UnaryExpr: ast::Expr = {
	"&" <e: UnaryExpr> => ast::Expr::GetRef(Box::new(e)),
	"*" <e: UnaryExpr> => ast::Expr::Deref(Box::new(e)),
	"~" <e: UnaryExpr> => ast::Expr::Unop(ast::UnaryOp::Bitnot, Box::new(e)),
	"!" <e: UnaryExpr> => ast::Expr::Unop(ast::UnaryOp::Lognot, Box::new(e)),
	"-" <e: UnaryExpr> => ast::Expr::Unop(ast::UnaryOp::Neg, Box::new(e)),
	<e: PostfixExpr> => e
}

PostfixExpr: ast::Expr = {
	<e1: PostfixExpr> "[" <e2: Expr> "]" => ast::Expr::Index(Box::new(e1), Box::new(e2)),
	"sizeof" "(" <t:Type> ")" => ast::Expr::Sizeof(t),
	"cast" "(" <t:Type> "," <e: Expr> ")" => ast::Expr::Cast(t, Box::new(e)),
	<i:Identifier> "(" <args: Comma<Expr>> ")"  => ast::Expr::Call(i, args),
	<i:Identifier> "@" "<" <t:Type> ">" "(" <args: Comma<Expr>> ")" => ast::Expr::GenericCall{name: i, type_param: t, args: args},
	<e1: PostfixExpr> "." <id:Identifier> => ast::Expr::Proj(Box::new(e1), id),
	<e: PrimaryExpr> => e
}

PrimaryExpr: ast::Expr = {
	"null" => ast::Expr::LitNull,

	"true" => ast::Expr::LitBool(true),
	"false"=> ast::Expr::LitBool(false),

	//signed ints look like '123' or '0x123'
	<s:r"[0-9]+"> => ast::Expr::LitSignedInt(i64::from_str_radix(s, 10).unwrap()),
	<s:r"0(x|X)[0-9a-fA-F]+"> => ast::Expr::LitSignedInt(i64::from_str_radix(&s[2..], 16).unwrap()),

	//unsigned ints look like '123u' or '0x123u'
	<s:r"[0-9]+u"> => ast::Expr::LitUnsignedInt(u64::from_str_radix(&s[.. s.len()-1], 10).unwrap()),
	<s:r"0(x|X)[0-9a-fA-F]+u"> => ast::Expr::LitUnsignedInt(u64::from_str_radix(&s[2.. s.len()-1], 16).unwrap()),

	//numeric literals with a decimal point become 64-bit floats
	//There has to be at least one digit after the decimal point
	<s:r"[0-9]*\.[0-9]+"> => ast::Expr::LitFloat(s.parse::<f64>().unwrap()),

	//TODO: string escape sequences
	<s:r#""[^"]*""#> => ast::Expr::LitString(String::from(&s[1..s.len()-1])),

	<id:Identifier> => ast::Expr::Id(id),

	"(" <e:Expr> ")" => e
}

Block: Vec<ast::Stmt> = {
	"{" <s:(<Stmt>)*> "}" => s
}

pub Stmt: ast::Stmt = {
	<lhs: Expr> "=" <rhs: Expr> ";" => ast::Stmt::Assign(lhs, rhs),

	<t: Type> <i:Identifier> ";" => ast::Stmt::Decl(t, i),

	"return" <e: Expr?> ";" => ast::Stmt::Return(e),

	<i:Identifier> "(" <args: Comma<Expr>> ")" ";" => ast::Stmt::SCall(i, args),
	<i:Identifier> "@" "<" <t:Type> ">" "(" <args: Comma<Expr>> ")" ";" => ast::Stmt::GenericSCall{name: i, type_param: t, args: args},

	"while" <cond: Expr> <body:Block> => ast::Stmt::While(cond, body),

	<i:IfStmt> => i
}

IfStmt: ast::Stmt = {
	"if" <cond: Expr> <b1: Block> <b2: ElseStmt> => ast::Stmt::If(cond, b1, b2)
}

ElseStmt: Vec<ast::Stmt> = {
	=> vec![],
	"else" <b: Block> => b,
	"else" <s: IfStmt> => vec![s]
}

PolyMode: ast::PolymorphMode = {
	"separated" => ast::PolymorphMode::Separated,
	"erased" => ast::PolymorphMode::Erased
}

FuncParam: Vec<(ast::Ty, String)> = {
	<x:Comma<(Type Identifier)>> => x
}

pub GDecl: ast::Gdecl = {
	"extern" <ret_ty: Type> <name: Identifier> "(" <arg_types: Comma<Type>> ")" ";" => ast::Gdecl::Extern{
		ret_type: Some(ret_ty),
		name,
		arg_types
	},
	
	"extern" "void" <name: Identifier> "(" <arg_types: Comma<Type>> ")" ";" => ast::Gdecl::Extern{
		ret_type: None,
		name,
		arg_types
	},
	
	<t: Type> <name: Identifier> ";" => ast::Gdecl::GVarDecl(t, name),

	<ret: Type> <fname: Identifier> "(" <fargs: FuncParam> ")" <b:Block> => ast::Gdecl::GFuncDecl{
		ret_type: Some(ret),
		name: fname,
		args: fargs,
		body: b
	},
	"void" <fname: Identifier> "(" <fargs: FuncParam> ")" <b:Block> => ast::Gdecl::GFuncDecl{
		ret_type: None,
		name: fname,
		args: fargs,
		body: b
	},

	<ret: Type> <fname: Identifier> "@" "<" <mode: PolyMode> "'" <var:Identifier> ">" "(" <fargs: FuncParam> ")" <b:Block> => ast::Gdecl::GGenericFuncDecl{
		ret_type: Some(ret),
		name: fname,
		args: fargs,
		body: b,
		var,
		mode: mode
	},
	"void" <fname: Identifier> "@" "<" <mode: PolyMode> "'" <var:Identifier> ">" "(" <fargs: FuncParam> ")" <b:Block> => ast::Gdecl::GGenericFuncDecl{
		ret_type: None,
		name: fname,
		args: fargs,
		body: b,
		var,
		mode: mode
	},

	"struct" <n:Identifier> "{" <field_list: (<Type> <Identifier> ";")*> "}" => ast::Gdecl::GStructDecl{
		name: n,
		fields: field_list
	},

	"struct" <n:Identifier> "@" "<" <mode: PolyMode> "'" <var:Identifier> ">"
		"{" <field_list: (<Type> <Identifier> ";")*> "}" => ast::Gdecl::GGenericStructDecl{
		name: n,
		var,
		mode: mode,
		fields: field_list
	}
}

pub Program: Vec<ast::Gdecl> = {
	<p:(<GDecl>)*> => p
}
